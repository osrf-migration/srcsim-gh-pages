{"priority": "major", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/osrf/srcsim.json"}, "html": {"href": "#!/osrf/srcsim"}, "avatar": {"href": "data/bytebucket.org/ravatar/{c41021d9-0217-4628-999d-7f8d82f98dcb}ts=c_plus_plus"}}, "type": "repository", "name": "srcsim", "full_name": "osrf/srcsim", "uuid": "{c41021d9-0217-4628-999d-7f8d82f98dcb}"}, "links": {"attachments": {"href": "data/repositories/osrf/srcsim/issues/182/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/srcsim/issues/182.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/srcsim/issues/182/watch"}, "comments": {"href": "data/repositories/osrf/srcsim/issues/182/comments_page=1.json"}, "html": {"href": "#!/osrf/srcsim/issues/182/docker-base-image"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/srcsim/issues/182/vote"}}, "reporter": {"display_name": "Rud Merriam", "uuid": "{79efa10c-b8b6-4b55-9d05-7d0057e235cb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B79efa10c-b8b6-4b55-9d05-7d0057e235cb%7D"}, "html": {"href": "https://bitbucket.org/%7B79efa10c-b8b6-4b55-9d05-7d0057e235cb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:c6ed1bc6-3112-49ac-9453-b3846fe562dc/5c7bde69-befb-417b-9aae-9db0c9a59777/128"}}, "nickname": "rmerriam", "type": "user", "account_id": "557058:c6ed1bc6-3112-49ac-9453-b3846fe562dc"}, "title": "Docker Base Image", "component": {"name": "cloud", "links": {"self": {"href": "data/repositories/osrf/srcsim/components/395697.json"}}}, "votes": 0, "watches": 4, "content": {"raw": "I've been working on the docker setup locally with some success, which is amazing. \r\n\r\n**Suggestion:** The docker file \"FROM\" command uses an existing image as the base for a new image. The example fcomputer uses\r\n```\r\n#!c++\r\n\r\nFROM ros:indigo-ros-base\r\n```\r\nto start the docker build. How about creating a base image, *src_base*, that contains the other ROS, OpenCV, IHMC, srcsim, etc software that is going to be used by all of us. This would greatly speed up the deployment to the field computer. Teams could still add more to their image on deployment. I know it works because I just did it locally. \r\n\r\n**Question:** It worked locally but want to check that I having my actual executable in github and executing i, rather than building online, is feasible. Bluntly, I've not been using catkin to build my C++ code and would rather not spend the time retrofitting into the catkin system.", "markup": "markdown", "html": "<p>I've been working on the docker setup locally with some success, which is amazing. </p>\n<p><strong>Suggestion:</strong> The docker file \"FROM\" command uses an existing image as the base for a new image. The example fcomputer uses</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">FROM</span> <span class=\"nl\">ros</span><span class=\"p\">:</span><span class=\"n\">indigo</span><span class=\"o\">-</span><span class=\"n\">ros</span><span class=\"o\">-</span><span class=\"n\">base</span>\n</pre></div>\n\n\n<p>to start the docker build. How about creating a base image, <em>src_base</em>, that contains the other ROS, OpenCV, IHMC, srcsim, etc software that is going to be used by all of us. This would greatly speed up the deployment to the field computer. Teams could still add more to their image on deployment. I know it works because I just did it locally. </p>\n<p><strong>Question:</strong> It worked locally but want to check that I having my actual executable in github and executing i, rather than building online, is feasible. Bluntly, I've not been using catkin to build my C++ code and would rather not spend the time retrofitting into the catkin system.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2017-05-24T00:01:34.719847+00:00", "milestone": null, "updated_on": "2017-05-25T22:20:54.726320+00:00", "type": "issue", "id": 182}